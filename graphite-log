#!/usr/bin/perl

# purpose:  parse log files (using logtail) for interesting lines.  

# TODO:  
#   * test fail2ban logs
#   * debug exim logs
#   * Apache logs
#   * Snort logs

use strict;
use Getopt::Long;
use vars qw (%Config);
use Time::Local;
use POSIX 'strftime';
no strict 'refs';
use Sys::Hostname;

our %Months = (
    "Jan" => 0,
    "Feb" => 1,
    "Mar" => 2,
    "Apr" => 3,
    "May" => 4,
    "Jun" => 5,
    "Jul" => 6,
    "Aug" => 7,
    "Sep" => 8,
    "Oct" => 9,
    "Nov" => 10,
    "Dec" => 11,
    );

$Config{syntax}="syslog";
$Config{currentYear}=&getCurrentYear();
$Config{bucket}=60;
$Config{prefix}="system." . hostname;

unless(GetOptions(
    "debug" => \$Config{debug},
    "syntax=s" => \$Config{syntax},
    "bucket=s" => \$Config{bucket},
    "prefix=s" => \$Config{prefix},
    "graphite-server=s" => \$Config{graphite},
    "current-year=s" => \$Config{currentYear},
    "file=s@" => \$Config{files},
       )) {
    print STDERR "Invalid usage\n";
    exit 1;
}

&main;

sub main {

    my $parser = "readfrom_$Config{syntax}";
    my $graphite;

    my $statedir;

    # effective user ID is root
    if($> eq 0) {
	$statedir="/var/lib/graphite-log";
    }
    else {
	$statedir=$ENV{HOME} . "/.graphite-log";
    }

    &debug("State dir is $statedir");
    mkdir $statedir unless -d $statedir;

    if($Config{graphite}) {
	my ($host, $port) = split(/:/, $Config{graphite});
	$port = 2003 unless $port;
	open($graphite, "|nc -q 2 $host $port") || die("Failed to netcat $host $port: $!");

	select $graphite;
    }

    my @matchers = &parseMatchers(@ARGV);

    my $keys = {};

    foreach my $file (@{$Config{files}}) {
	&debug("Starting $file");
	my ($date, $message, $bucket, $lastbucket);
	my $counter;

	my $filekey;
	unless($file eq "-") {
	    $filekey = $file;
	    $filekey =~ s/[^a-zA-Z0-9_]/_/g;
	}

	my $state = $file;
	$state =~ s/\//_/g;
	$state = "$statedir/$state";
	mkdir $state unless -d $state;
	&debug("State for $file is $state");

	($bucket, $keys) = &readState($state);

	my $log;

	if ($file eq "-") {
	    $log=\*STDIN;
	}
	else {
	    my $cmd = "/usr/sbin/logtail2 -f $file -o $state/logtail.state";
	    &debug("$cmd");
	    open($log, "$cmd|" ) || die("Failed to read from $file: $!");
	}

	do {
	    ($date, $message) = &$parser($log);

	    $bucket = int($date/$Config{bucket});

	    if($lastbucket != $bucket && $lastbucket > 0) {
		&dump($counter, $lastbucket*$Config{bucket}, $keys);
		&catchup($lastbucket, $bucket, $keys);
		$counter={};
	    }

	    $lastbucket = $bucket;

	    if($date) {
		$counter->{"log.$filekey.lines"}++ if $filekey;
		foreach my $matcher (@matchers) {
		    my $re =  $matcher->{re};

#		    &debug("Checking $message against /$re/");
		    $_ = $message;
		    if(/$re/) {
			my $key = $matcher->key;
			$keys->{$key}=1;
			$counter->{$key}++;
		    }
		}
	    }
	} while ($date);
	close $log;
	&recordState($state, $bucket, $keys);
	&debug("Done with $file");
    }

    &debug("Done with all files");
    close $graphite if $graphite;
    &debug("Connection to graphite closed");
    exit 0;
    &debug("Why are we still here after exit?");
}

sub readState {
    my $dir = shift;
    my $file = "$dir/log.state";

    return unless -f $file;

    open(my $fh, $file) || die("Failed to read $file: $!");

    my $bucket = <$fh>;

    return unless $bucket;
    chop $bucket;

    my $keys;

    while(<$fh>) {
	chop;
	$keys->{$_}=0;
    }
    
    close $fh;

    return ($bucket, $keys);
}

sub recordState {
    my $statefile = shift;
    my $bucket = shift;
    my $keys = shift;

    my $file = "$statefile/log.state";

    open(my $fh, ">$file") || die("Failed to record state to $file: $!");

    print $fh "$bucket\n";
    foreach my $key (keys %$keys) {
	print $fh "$key\n";
    }

    close $fh;
}

sub catchup {
    my $last = shift;
    my $this = shift;
    my $keys = shift;

    return unless $keys;

    if($Config{debug}) {
	my $lasttime = ($last+1)*$Config{bucket};
	my $thistime = $this*$Config{bucket};

	&debug("Catching up from $lasttime to $thistime");
    }

    for(my $bucket = $last+1; $bucket<$this; $bucket++) {
	foreach my $key (keys %$keys) {
	    my $date = $bucket*$Config{bucket};
	    &write($key, 0, $date);
	}
    }
}

sub parseMatchers {
    my @matchers;

    foreach my $arg (@_) {
	push(@matchers, new Matcher($arg));
    }

    return @matchers;
}

sub dump {
    my $counter = shift;
    my $date = shift;
    my $keys = shift;

    &debug("Dumping for $date");

    foreach my $key (keys %$keys) {
	$counter->{$key} = 0 unless 	$counter->{$key};
    }

    foreach my $key (keys %$counter) {
	my $metric = "$Config{prefix}.$key";
	my $value = $counter->{$key};
	print "$metric $value $date\n";
    }
}

sub write {
    my $prefix = $Config{prefix};
    my $key = shift;
    my $value = shift;
    my $date = shift;

    $value = 1 unless defined($value);

    print "$prefix.$key $value $date\n";
}
# 2011-10-29 07:13:13 1RK6qa-0001Gm-EV Completed
sub readfrom_denyhosts {
    my $fh = shift;

    return unless ($_ = <$fh>);

    &debug("line is [$_]");

    my ($year, $month, $mday, $hour, $min, $sec, $millis, $message) = split(/[-: ,]+/, $_, 8);

    &debug("$year $month $mday");

    my $now = strftime("%s", $sec, $min, $hour, $mday, $month-1, $year-1900);

    &debug("at $now, message is $message");

    return ($now, $message);
}

# 2011-10-29 07:13:13 1RK6qa-0001Gm-EV Completed
sub readfrom_exim {
    my $fh = shift;

    return unless ($_ = <$fh>);

    my ($year, $month, $mday, $hour, $min, $sec, $millis, $message) = split(/[-: ]+/, $_, 8);

    my $now = strftime("%s", $sec, $min, $hour, $mday, $month-1, $year-1900);

    &debug("at $now, message is $message");

    return ($now, $message);
}

# 2011-10-23 06:27:19,861 fail2ban.filter : INFO   Log rotation detected for /var/log/auth.log
sub readfrom_fail2ban {
    my $fh = shift;

    return unless ($_ = <$fh>);

    my ($year, $month, $mday, $hour, $min, $sec, $millis, $message) = split(/[-: ,]+/, $_, 8);

    my $now = strftime("%s", $sec, $min, $hour, $mday, $month-1, $year-1900);

    return ($now, $message);
}

# Nov  2 21:14:56 johnlittle rsyslogd: [origin software="rsyslogd" swVersion="4.2.0" x-pid="1628" x-info="http://www.rsyslog.com"] rsyslogd was HUPed, type 'lightweight'.

sub readfrom_syslog {
    my $fh = shift;

    my $line;
    return undef unless ($line = <$fh>);
    chop $line;

    my ($month, $mday, $hour, $min, $sec, $message) = split(/[ :]+/,$line, 6);

    my $mon = $Months{$month};
    my $year = $Config{currentYear}-1900;

    die("Failed to interpret $month as month") unless defined($mon);

    my $now = strftime("%s", $sec, $min, $hour, $mday, $mon, $year);

    &debug("Converting $sec $min $hour $mday $mon $year to $now");

    return ($now, $message);
}

sub getCurrentYear {
    my  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();

    return $year+ 1900;
}

sub debug {
    return unless $Config{debug};

    if($Config{graphite}) {
	print STDERR "@_\n";
    }
    else {
	print STDOUT "@_\n";
    }
}

package Matcher;

sub new {
    my $self = {};
    my $class = shift;
    my $line = shift;

    bless $self, $class;

    my ($key, $re);

    if($line =~ /=/) {
	($key, $re) = split(/=/, $line, 2);
    } else {
	$key = $re = $line;
    }

    $self->{key}=$key;
    $self->{re}=$re;

    &main::debug("matcher $key matches /$re/");

    return $self;
}


sub key {
    my $self = shift;
    my $key = $self->{key};

    my %bound;

    $bound{1}=$1;
    $bound{2}=$2;
    $bound{3}=$3;

    return $key unless $key =~ /\$/;

    $key =~ s/\$([0-9])/$bound{$1}/;

    print "key now $key\n";

    return $key;
}

