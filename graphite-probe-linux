#!/usr/bin/perl

# Purpose: collect various system stats and report them to graphite
#  We're not using one of the myriad of tools available for this
#  purpose because they all seem to handle LVM block devices poorly.

use Time::Local;
use Getopt::Long; 
use strict;
use vars '%Config', '@Columns';
use POSIX 'strftime';
use Sys::Hostname;
use File::Basename;

$Config{date}=strftime("%s", localtime);

our %Options=(
	   "prefix=s"  => \$Config{prefix},
	   "show-drives=s" => \$Config{showDrive},
	   "column=s@" => \@Columns,
	   "graphite-host=s" => \$Config{graphiteHost},
    );

unless(GetOptions(%Options)) {
    die("Failed to parse options");
}
unless(defined $Config{prefix}) {
    $Config{prefix} = "system." . hostname ;
}

&processFileOptions;


&main;

sub main {

    my $graphite;

    if($Config{graphiteHost}) {
	my ($host, $port) = split(/:/, $Config{graphiteHost});
	$port = 2003 unless $port;
	open($graphite, "|nc $host $port") || die("Failed to netcat to $host:$port: $!");
	select $graphite;
    }


    &probe_cpu;
    &probe_load;
    &probe_disk;
    &probe_network;


    close($graphite) if $graphite;
}

sub processFileOptions {
    my $file = "$0.options";

    return unless -r $file;

    open(my $options, $file) || die("Failed to read $file: $!");
    @ARGV=();

    while(<$options>) {
	next if /^\s*#/;
	next if /^\s*$/;
	chop if /[\r\n]$/;
	push(@ARGV, split(/\s+/));
    }

    close $options;

    &GetOptions(%Options);
}

# cat /proc/net/dev
#Inter-|   Receive                                                |  Transmit
# face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed
#  lo:709708566 2367582    0    0    0     0          0         0 709708566 2367582    0    0    0     0       0          0
#  eth0:3874460054 88403338 6793 7034    0     0          0         0 1638409025 11341491    0    0    0     0       0          0

sub probe_network {
    my $fd;

    open($fd, "/proc/net/dev") || die("Failed to read /proc/net/dev: $!");

    <$fd>; # throw away first line
    <$fd>; # throw away main header line

    while(<$fd>) 
    {
	chop;
	s/^\s+//;
	my ($iface, 
	    $rx_bytes, $rx_packets, $rx_errs, $rx_drop, $rx_fifo, $rx_frame, $rx_compressed, $rx_multicast, 
	    $tx_bytes, $tx_packets, $tx_errs, $tx_drop, $tx_fifo, $tx_frame, $tx_compressed, $tx_multicast) = split(/[\s:]+/, $_);

	die("Failed to read interface") unless $iface;

	next if $iface eq "lo";
	next unless $iface =~ /^eth/;
	&write("network.$iface.receive.byte_count", $rx_bytes);
	&write("network.$iface.receive.packet_count", $rx_packets);
#	&write("network.$iface.receive.packet-errors", $rx_errs);
#	&write("network.$iface.receive.packets-dropped", $rx_drop);
	&write("network.$iface.transmit.byte_count", $tx_bytes);
	&write("network.$iface.transmit.packet_count", $tx_packets);
#	&write("network.$iface.transmit.packet-errors", $tx_errs);
#	&write("network.$iface.transmit.packets-dropped", $tx_drop);
    }

    close($fd);
}

sub probe_disk { 
    open(my $file, "/proc/diskstats") || return 0;

    my @totals=(0,0,0,0,0,0,0,0,0,0,0,0,0);
    my $map = {};
    my $showRe = "   none    ";
    if($Config{showDrive}) {
	$map = &getDriveMap;
	$showRe = $Config{showDrive};
    }

    while(<$file>) {
	# trim leading whitespace
	$_ =~ s/^\s*//;
	my @drive = split(/\s+/);
	my $name = $drive[2];
	$drive[2] = &getDriveFromMap(@drive[2], $map);
	&writeDisk(@drive) if ($name =~ /$showRe/ || $drive[2] =~ /$showRe/);

	next unless $drive[2] =~ /^bydrive\.sd[a-z]$/;

	for(my $i=3; $i<14; $i++) {
	    $totals[$i]+=$drive[$i];
	}
    }

    $totals[2]="all";

    &writeDisk(@totals);

    close $file;
}

sub getDriveFromMap {
    my $drive = shift;
    my $map = shift;

    my $result = $map->{$drive};

    my $category = "bydrive";

    $category = "byvolume" if $drive =~ /^dm-/;
    $category = "byraid" if $drive =~ /^md\d+$/;
    $category = "bypartition" if $drive =~ /^sd\w\d$/;

    return "$category.$result" if $result;

    return "$category.$drive";
}

sub getDriveMap {
    my $map;
    open(my $ls, "ls -l /dev/mapper |") || die("Failed to read ls /dev/mapper: $!");

    while(<$ls>) {
	chop;
	# lines like
	# lrwxrwxrwx 1 root root      7 2011-11-23 21:47 system-root--snapshot -> ../dm-3

	my ($name, $drive);

	if(/([a-zA-Z0-9_-]+) -> ..\/(dm-\d+)/) {
	    ($name, $drive) = ($1, $2);
	}

	# lines like
	# brw-rw---- 1 root disk 252, 20 2011-11-02 19:01 storage-svn
	if(/^b.*252,\s+(\d+)\s+[\s\d:-]+([^\s]+)/) {
	    $name = $2;
	    $drive = "dm-$1";
	}

	$name =~ s/--/\*/g;
	$name =~ s/-/_/g;
	$name =~ s/\*/-/g;
	
	$map->{$drive}=$name
    }

    close $ls;
    return $map;
}

sub writeDisk {
    my ($major, $minor, $name, 
	$reads, $readsmerged, $readsectors, $readtime, 
	$writes, $writemerged, $writesectors, $writetime,
	$outstanding, $iotime, $weighted) = @_;

	&write("disk.$name.read.op_count", $reads);
	&write("disk.$name.read.merged_op_count", $readsmerged);
        &write("disk.$name.read.time.millis", $readtime);

	&write("disk.$name.write.op_count", $writes);
	&write("disk.$name.write.merged_op_count", $writemerged);
        &write("disk.$name.write.time.millis", $writetime);

	&write("disk.$name.read.byte_count", $readsectors*512);
	&write("disk.$name.write.byte_count", $writesectors*512);

	&write("disk.$name.queuesize", $outstanding);
        &write("disk.$name.time.weighted_ms", $weighted);

}


sub probe_cpu {
    open(my $cpu, "/proc/stat") || return 0;
    my $cpuCount;

    my ($endText, $endUser, $endNice, $endSystem, $endIdle, $endIowait, $endIrq, $endSoftirq);

    while(<$cpu>) {
	$cpuCount++ if /^cpu\d/;
	if(/^cpu /) {
	($endText, $endUser, $endNice, $endSystem, $endIdle, $endIowait, $endIrq, $endSoftirq) = split(/\s+/);
	}
    }

    close $cpu;

    &write("cpu.time.user_seconds_count", ($endUser)/$cpuCount/100);
    &write("cpu.time.system_seconds_count", ($endSystem)/$cpuCount/100);
    &write("cpu.time.iowait_seconds_count", ($endIowait)/$cpuCount/100);

}

sub probe_load {
    open(my $loadavg, "/proc/loadavg") || return 0;
    while(<$loadavg>) {
	chop;
	my ($min1, $min5, $min15, $ready, $total, $last) = split(/[\s\/]+/);
	&write("cpu.load_average.1_minute", $min1);
#	&write("cpu.load_average.5_minute", $min5);
    }

    close $loadavg;
}

sub write {
    my $subkey = shift;
    my $value = shift;
    $value = 0 unless $value;

    print "$Config{prefix}.$subkey $value $Config{date}\n";
}
